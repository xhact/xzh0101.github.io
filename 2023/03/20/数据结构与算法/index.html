<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    <meta name="description" content="Hexo Theme Redefine">
    <meta name="author" content="The Redefine Team">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-redefine.png">
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2023/03/20/数据结构与算法/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Hexo">
    <meta property="og:description" content="Hexo Theme Redefine">
    <meta property="og:url" content="http://example.com2023/03/20/数据结构与算法/">
    <meta property="og:image" content="/images/redefine-logo.svg">
    <meta property="og:site_name" content="Theme Redefine">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Hexo">
    <meta name="twitter:description" content="Hexo Theme Redefine">
    <meta name="twitter:image" content="/images/redefine-logo.svg">
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-logo.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-logo.svg">
    <meta name="theme-color" content="#005080">
    <link rel="shortcut icon" href="/images/redefine-logo.svg">
    
    <title>
        
        Theme Redefine
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/assets/fonts.css">

    
    
    
    
    <script id="hexo-configurations">
    let REDEFINE = window.REDEFINE || {};
    REDEFINE.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    REDEFINE.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#005080","avatar":"/images/redefine-avatar.svg","favicon":"/images/redefine-logo.svg","article_img_align":"center","right_side_width":"210px","content_max_width":"1000px","nav_color":{"left":"#f78736","right":"#367df7","transparency":35},"hover":{"shadow":true,"scale":false},"first_screen":{"enable":true,"background_image":{"light":"https://evan.beee.top/img/wallhaven-wqery6-light.webp","dark":"https://evan.beee.top/img/wallhaven-wqery6-dark.webp"},"title_color":{"light":"#fff","dark":"#d1d1b6"},"description":"Theme Redefine","custom_font":{"enable":false,"font_family":null,"font_url":null}},"scroll":{"progress_bar":{"enable":true},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":true},"code_block":{"copy":true,"style":"mac","custom_font":{"enable":false,"font_family":null,"font_url":null}},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"1.1.4","friend_links":{"columns":2},"home_article":{"date_format":"auto","category":{"enable":true,"limit":3},"tag":{"enable":true,"limit":3}},"plugins":{"aplayer":{"enable":false,"audio":[{"name":null,"artist":null,"url":null,"cover":null},{"name":null,"artist":null,"url":null,"cover":null}]}}};
    REDEFINE.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
    
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    
        <span class="scroll-progress-bar"></span>
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fa-solid fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="menu-wrapper">
    
    <div class="menu-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                Theme Redefine
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="pc">
                <ul class="menu-list">
                    
                        
                            <li class="menu-item">
                                <!-- Menu -->
                                <a class="" 
                                    href="/"  >
                                    
                                        
                                            <i class="fa-regular fa-house"></i>
                                        
                                        HOME
                                    
                                </a>
                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile drawer -->
    <div class="menu-drawer">
        <ul class="drawer-menu-list">
            
                
                    <li class="drawer-menu-item flex-center">
                        <a class="" 
                        href="/"  >
                             
                                
                                    <i class="fa-regular fa-house"></i>
                                
                                HOME
                            
                        </a>
                    </li>
                    <!-- Submenu -->
                    
            

        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="post-page-container">
        <div class="article-content-container">

            
            
                <div class="article-title">
                    <h1 class="article-title-regular"></h1>
                </div>
            
                
            

            
                <div class="article-header">
                    <div class="avatar">
                        <img src="/images/redefine-avatar.svg">
                    </div>
                    <div class="info">
                        <div class="author">
                            <span class="name">The Redefine Team</span>
                            
                                <span class="author-label">lol</span>
                            
                        </div>
                        <div class="meta-info">
                            <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="pc">2023-03-20 15:21:58</span>
        <span class="mobile">2023-03-20 15:21</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="pc">2023-04-04 12:30:55</span>
            <span class="mobile">2023-04-04 12:30</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                        </div>
                    </div>
                </div>
            

            <div class="article-content markdown-body">
                <h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><p>在编写程序时，我们需要考虑如下问题：如何描述所涉及的数据的逻辑关系，如何存储这些数据及其逻辑关系，如何设计和实现对数据的操作算法。</p>
<h2 id="1-数据结构和算法内容介绍"><a href="#1-数据结构和算法内容介绍" class="headerlink" title="1.数据结构和算法内容介绍"></a>1.数据结构和算法内容介绍</h2><h3 id="1-1-1先看几个经典的算法面试题"><a href="#1-1-1先看几个经典的算法面试题" class="headerlink" title="1.1.1先看几个经典的算法面试题"></a>1.1.1先看几个经典的算法面试题</h3><h4 id="字符串匹配问题"><a href="#字符串匹配问题" class="headerlink" title="字符串匹配问题"></a>字符串匹配问题</h4><ol>
<li>​    判断 str1 是否含有 str2 ，如果存在，就返回第一次出现的位置，如果没有，则返回-1</li>
<li>要求用最快的速度来完成匹配</li>
</ol>
<ul>
<li>暴力匹配（简单，但是效率低）</li>
<li>KMP算法（部分匹配表）</li>
</ul>
<h4 id="汉诺塔"><a href="#汉诺塔" class="headerlink" title="汉诺塔"></a>汉诺塔</h4><h4 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h4><h4 id="马踏棋盘"><a href="#马踏棋盘" class="headerlink" title="马踏棋盘"></a>马踏棋盘</h4><h2 id="2-数据结构和算法"><a href="#2-数据结构和算法" class="headerlink" title="2.数据结构和算法"></a>2.数据结构和算法</h2><h3 id="2-1数据结构和算法的关系"><a href="#2-1数据结构和算法的关系" class="headerlink" title="2.1数据结构和算法的关系"></a>2.1数据结构和算法的关系</h3><ol>
<li>数据（data）结构（structure）是一门研究组织数据方式的学科，有了编程语言也就有了数据结构，学好数据结构可以编写出更漂亮，更加有效率的代码</li>
<li>程序=数据结构+算法</li>
</ol>
<h3 id="2-2实际编程中遇到的问题"><a href="#2-2实际编程中遇到的问题" class="headerlink" title="2.2实际编程中遇到的问题"></a>2.2实际编程中遇到的问题</h3><ul>
<li>修路问题=》最小生成树（数据结构+普利姆算法）</li>
<li>最短路径问题=》佛洛伊德算法</li>
<li>汉诺塔=》分支算法</li>
<li>八皇后问题=》回溯法</li>
</ul>
<h3 id="2-3数据结构"><a href="#2-3数据结构" class="headerlink" title="2.3数据结构"></a>2.3数据结构</h3><ul>
<li>线性结构<ol>
<li>线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系</li>
<li>线性结构有不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的</li>
<li>链式存续的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息</li>
<li>线性结构常见的有：数组，队列，链表和栈，后面我们会详细讲解</li>
</ol>
</li>
<li>非线性结构<ol>
<li>非线性结构包括：二维数组，多维数组，广义表，树结构，图结构</li>
</ol>
</li>
</ul>
<h2 id="3-稀疏sparsearray数组"><a href="#3-稀疏sparsearray数组" class="headerlink" title="3.稀疏sparsearray数组"></a>3.稀疏sparsearray数组</h2><h3 id="3-1基本介绍"><a href="#3-1基本介绍" class="headerlink" title="3.1基本介绍"></a>3.1基本介绍</h3><ul>
<li>当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组</li>
<li>处理方法：<ol>
<li>记录数组一共有几行几列，有多少个不同的值</li>
<li>把具有不同值的元素的行列及值记录在小规模的数组（稀疏数组）中，从而缩小程序的规模</li>
</ol>
</li>
</ul>
<h3 id="3-2稀疏数组和二维数组的转换"><a href="#3-2稀疏数组和二维数组的转换" class="headerlink" title="3.2稀疏数组和二维数组的转换"></a>3.2稀疏数组和二维数组的转换</h3><p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230402132342157.png" alt="image-20230402132342157"></p>
<h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4.队列"></a>4.队列</h2><h3 id="4-1介绍"><a href="#4-1介绍" class="headerlink" title="4.1介绍"></a>4.1介绍</h3><ol>
<li>队列是一个有序列表，可以用数组或链表来实现</li>
<li>遵循先入先出的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li>
<li>示意图：<img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230402134750008.png" alt="image-20230402134750008"></li>
<li>数组模拟<ul>
<li>队列本身是有序列表</li>
<li>因为队列的输出，输入是分别从前后端来处理，因此需要两个变量front及rear分别记录队列前后端的下标，front会随着数据输出而改变，而rear则是随着数据输入而改变</li>
</ul>
</li>
<li>数组模拟队列<ol>
<li>将尾指针往后移：rear+1，要先判断front==rear[空]</li>
<li>若尾指针rear小于队列的最大下标maxSize-1，则将数据存入rear所指的数组元素中，否则无法存入数据。rear==maxSize-1[队列满]</li>
</ol>
</li>
<li>数组模拟环形队列<ol>
<li> front 变量的含义做一个调整： front 就指向队列的第一个元素, 也就是说 arr[front] 就是队列的第一个元素<br>front 的初始值 = 0</li>
<li> rear 变量的含义做一个调整：rear 指向队列的最后一个元素的后一个位置. 因为希望空出一个空间做为约定.<br>rear 的初始值 = 0</li>
<li>当队列满时，条件是  (rear  + 1) % maxSize == front 【满】</li>
<li>对队列为空的条件， rear == front 空</li>
<li>当我们这样分析， 队列中有效的数据的个数   (rear + maxSize - front) % maxSize   // rear = 1 front = 0 </li>
</ol>
</li>
</ol>
<h2 id="5-链表"><a href="#5-链表" class="headerlink" title="5.链表"></a>5.链表</h2><p>链表是有序的列表</p>
<h3 id="5-1存储方式"><a href="#5-1存储方式" class="headerlink" title="5.1存储方式"></a>5.1存储方式</h3><p>1.链表是以节点的方式来存储,是链式存储<br>2.每个节点包含 data 域， next 域：指向下一个节点.<br>3.如图：发现链表的各个节点不一定是连续存储.<br>4.链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230402155848026.png" alt="image-20230402155848026"></p>
<h3 id="5-2逻辑结构"><a href="#5-2逻辑结构" class="headerlink" title="5.2逻辑结构"></a>5.2逻辑结构</h3><p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230402160042423.png" alt="image-20230402160042423"></p>
<h3 id="5-3双向链表应用"><a href="#5-3双向链表应用" class="headerlink" title="5.3双向链表应用"></a>5.3双向链表应用</h3><p>管理单向链表的缺点分析:<br>1.单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。<br>2.单向链表不能自我删除，需要靠辅助节点 ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).</p>
<h3 id="5-4单向环形链表应用场景"><a href="#5-4单向环形链表应用场景" class="headerlink" title="5.4单向环形链表应用场景"></a>5.4单向环形链表应用场景</h3><p>Josephu(约瑟夫、约瑟夫环)  问题<br>Josephu  问题为：设编号为1，2，… n的n个人围坐一圈，约定编号为k（1&lt;=k&lt;=n）的人从1开始报数，数到m 的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。</p>
<p>提示：用一个不带头结点的循环链表来处理Josephu 问题：先构成一个有n个结点的单循环链表，然后由k结点起从1开始计数，计到m时，对应结点从链表中删除，然后再从被删除结点的下一个结点又从1开始计数，直到最后一个结点从链表中删除算法结束。</p>
<h2 id="6-栈"><a href="#6-栈" class="headerlink" title="6.栈"></a>6.栈</h2><h3 id="6-1介绍"><a href="#6-1介绍" class="headerlink" title="6.1介绍"></a>6.1介绍</h3><p>栈的英文为(stack)<br>栈是一个先入后出(FILO-First In Last Out)的有序列表。<br>栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。<br>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p>
<h3 id="6-2应用场景"><a href="#6-2应用场景" class="headerlink" title="6.2应用场景"></a>6.2应用场景</h3><p>子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。<br>处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。<br>表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。<br>二叉树的遍历。<br>图形的深度优先(depth一first)搜索法。</p>
<h3 id="6-3实现栈的思路分析"><a href="#6-3实现栈的思路分析" class="headerlink" title="6.3实现栈的思路分析"></a>6.3实现栈的思路分析</h3><ol>
<li>使用数组来模拟栈</li>
<li>定义一个 top  来表示栈顶，初始化 为  -1</li>
<li>入栈的操作，当有数据加入到栈时， top++;  stack[top] = data;</li>
<li>出栈的操作， int value = stack[top]; top–, return value</li>
</ol>
<h3 id="6-4使用栈完成表达式的计算-思路"><a href="#6-4使用栈完成表达式的计算-思路" class="headerlink" title="6.4使用栈完成表达式的计算 思路"></a>6.4使用栈完成表达式的计算 思路</h3><ol>
<li>通过一个 index  值（索引），来遍历我们的表达式</li>
<li>如果我们发现是一个数字, 就直接入数栈</li>
<li>如果发现扫描到是一个符号,  就分如下情况</li>
<li>1 如果发现当前的符号栈为 空，就直接入栈</li>
<li>2 如果符号栈有操作符，就进行比较,如果当前的操作符的优先级小于或者等于栈中的操作符， 就需要从数栈中pop出两个数,在从符号栈中pop出一个符号，进行运算，将得到结果，入数栈，然后将当前的操作符入符号栈， 如果当前的操作符的优先级大于栈中的操作符， 就直接入符号栈.</li>
<li>当表达式扫描完毕，就顺序的从 数栈和符号栈中pop出相应的数和符号，并运行.</li>
<li>最后在数栈只有一个数字，就是表达式的结果</li>
</ol>
<h2 id="7-前缀、中缀、后缀表达式-逆波兰表达式"><a href="#7-前缀、中缀、后缀表达式-逆波兰表达式" class="headerlink" title="7.前缀、中缀、后缀表达式(逆波兰表达式)"></a>7.前缀、中缀、后缀表达式(逆波兰表达式)</h2><h3 id="7-1前缀表达式-波兰表达式"><a href="#7-1前缀表达式-波兰表达式" class="headerlink" title="7.1前缀表达式(波兰表达式)"></a>7.1前缀表达式(波兰表达式)</h3><p>前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前</p>
<p>从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果</p>
<h3 id="7-2中缀表达式"><a href="#7-2中缀表达式" class="headerlink" title="7.2中缀表达式"></a>7.2中缀表达式</h3><p>中缀表达式就是常见的运算表达式，如(3+4)×5-6</p>
<p>中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作(前面我们讲的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式.)</p>
<h3 id="7-3后缀表达式"><a href="#7-3后缀表达式" class="headerlink" title="7.3后缀表达式"></a>7.3后缀表达式</h3><p>后缀表达式又称逆波兰表达式,与前缀表达式相似，只是运算符位于操作数之后</p>
<p>从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果</p>
<h3 id="7-4中缀表达式转换为后缀表达式"><a href="#7-4中缀表达式转换为后缀表达式" class="headerlink" title="7.4中缀表达式转换为后缀表达式"></a>7.4中缀表达式转换为后缀表达式</h3><p>初始化两个栈：运算符栈s1和储存中间结果的栈s2；<br>从左至右扫描中缀表达式；<br>遇到操作数时，将其压s2；<br>遇到运算符时，比较其与s1栈顶运算符的优先级：<br>    如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br>    否则，若优先级比栈顶运算符的高，也将运算符压入s1；<br>    否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；</p>
<p>遇到括号时：</p>
<p>​    (1) 如果是左括号“(”，则直接压入s1</p>
<p>​    (2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃<br>重复步骤2至5，直到表达式的最右边<br>将s1中剩余的运算符依次弹出并压入s2<br>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式</p>
<h2 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h2><p>递归就是方法自己调用自己,每次调用时传入不同的变量.递归有助于编程者解决复杂的问题,同时可以让代码变得简洁。</p>
<h3 id="8-1递归需要遵守的重要规则"><a href="#8-1递归需要遵守的重要规则" class="headerlink" title="8.1递归需要遵守的重要规则"></a>8.1递归需要遵守的重要规则</h3><p>执行一个方法时，就创建一个新的受保护的独立空间(栈空间)<br>方法的局部变量是独立的，不会相互影响, 比如n变量<br>如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据.<br>递归必须向退出递归的条件逼近，否则就是无限递归,出现StackOverflowError，死龟了:)<br>当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</p>
<h3 id="8-2八皇后问题算法思路分析"><a href="#8-2八皇后问题算法思路分析" class="headerlink" title="8.2八皇后问题算法思路分析"></a>8.2八皇后问题算法思路分析</h3><p>第一个皇后先放第一行第一列<br>第二个皇后放在第二行第一列、然后判断是否OK， 如果不OK，继续放在第二列、第三列、依次把所有列都放完，找到一个合适<br>继续第三个皇后，还是第一列、第二列……直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解<br>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到.<br>然后回头继续第一个皇后放第二列，后面继续循环执行 1,2,3,4的步骤</p>
<h2 id="9-排序算法"><a href="#9-排序算法" class="headerlink" title="9.排序算法"></a>9.排序算法</h2><p>排序是将一组数据，依指定的顺序进行排列的过程。<br>排序的分类：</p>
<ol>
<li>内部排序:<br>指将需要处理的所有数据都加载到内部存储器中进行排序。</li>
<li>外部排序法：<br>数据量过大，无法全部加载到内存中，需要借助外部存储进行<br>排序。</li>
</ol>
<p>3)</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403184829678.png" alt="image-20230403184829678"></p>
<h3 id="9-1冒泡排序"><a href="#9-1冒泡排序" class="headerlink" title="9.1冒泡排序"></a>9.1冒泡排序</h3><p>通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p>
<h3 id="9-2选择排序"><a href="#9-2选择排序" class="headerlink" title="9.2选择排序"></a>9.2选择排序</h3><p>第一次从arr[0]<del>arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]</del>arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]<del>arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]</del>arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。</p>
<h3 id="9-3插入排序"><a href="#9-3插入排序" class="headerlink" title="9.3插入排序"></a>9.3插入排序</h3><p>把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<h3 id="9-4希尔排序"><a href="#9-4希尔排序" class="headerlink" title="9.4希尔排序"></a>9.4希尔排序</h3><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p>
<h3 id="9-5快速排序"><a href="#9-5快速排序" class="headerlink" title="9.5快速排序"></a>9.5快速排序</h3><p>通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<h3 id="9-6归并排序"><a href="#9-6归并排序" class="headerlink" title="9.6归并排序"></a>9.6归并排序</h3><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<h3 id="9-7基数排序-桶排序"><a href="#9-7基数排序-桶排序" class="headerlink" title="9.7基数排序(桶排序)"></a>9.7基数排序(桶排序)</h3><ol>
<li>基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li>
<li>基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法</li>
<li>基数排序(Radix Sort)是桶排序的扩展</li>
<li>基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。</li>
</ol>
<h4 id="9-7-1基本思想"><a href="#9-7-1基本思想" class="headerlink" title="9.7.1基本思想"></a>9.7.1基本思想</h4><p>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。</p>
<h4 id="9-7-2说明"><a href="#9-7-2说明" class="headerlink" title="9.7.2说明"></a>9.7.2说明</h4><ol>
<li>基数排序是对传统桶排序的扩展，速度很快.</li>
<li>基数排序是经典的空间换时间的方式，占用内存很大, 当对海量数据排序时，容易造成 OutOfMemoryError 。</li>
<li>基数排序时稳定的。[注:假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]=r[j]，且r[i]在r[j]之前，而在排序后的序列中，r[i]仍在r[j]之前，则称这种排序算法是稳定的；否则称为不稳定的]</li>
<li>有负数的数组，我们不用基数排序来进行排序, 如果要支持负数，参考: <a class="link" target="_blank" rel="noopener" href="https://code.i-harness.com/zh-CN/q/e98fa9">https://code.i-harness.com/zh-CN/q/e98fa9 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> </li>
</ol>
<h4 id="9-8算法对比"><a href="#9-8算法对比" class="headerlink" title="9.8算法对比"></a>9.8算法对比</h4><p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230404085108604.png" alt="image-20230404085108604"></p>
<p>相关术语解释：</p>
<ol>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度： 一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
<li>n: 数据规模</li>
<li>k: “桶”的个数</li>
<li>In-place:    不占用额外内存</li>
<li>Out-place: 占用额外内存</li>
</ol>
<h2 id="10-算法的时间复杂度"><a href="#10-算法的时间复杂度" class="headerlink" title="10.算法的时间复杂度"></a>10.算法的时间复杂度</h2><h3 id="10-1度量一个程序-算法-执行时间的两种方法"><a href="#10-1度量一个程序-算法-执行时间的两种方法" class="headerlink" title="10.1度量一个程序(算法)执行时间的两种方法"></a>10.1度量一个程序(算法)执行时间的两种方法</h3><ol>
<li>事后统计的方法这种方法可行, 但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素, 这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</li>
<li>事前估算的方法通过分析某个算法的时间复杂度来判断哪个算法更优.</li>
</ol>
<h3 id="10-2时间频度"><a href="#10-2时间频度" class="headerlink" title="10.2时间频度"></a>10.2时间频度</h3><p>一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)（1.忽略常数项 2.忽略低次项 3.忽略系数）</p>
<h3 id="10-3时间复杂度"><a href="#10-3时间复杂度" class="headerlink" title="10.3时间复杂度"></a>10.3时间复杂度</h3><ol>
<li>一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n) / f(n) 的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作 T(n)=Ｏ( f(n) )，称Ｏ( f(n) )  为算法的渐进时间复杂度，简称时间复杂度。</li>
<li>T(n) 不同，但时间复杂度可能相同。 如：T(n)=n²+7n+6 与 T(n)=3n²+2n+2 它们的T(n) 不同，但时间复杂度相同，都为O(n²)。</li>
<li>计算时间复杂度的方法：<br>用常数1代替运行时间中的所有加法常数  T(n)=n²+7n+6  =&gt; T(n)=n²+7n+1<br>修改后的运行次数函数中，只保留最高阶项  T(n)=n²+7n+1 =&gt; T(n) = n²<br>去除最高阶项的系数 T(n) = n² =&gt; T(n) = n² =&gt; O(n²)</li>
</ol>
<h3 id="10-4常见的时间复杂度"><a href="#10-4常见的时间复杂度" class="headerlink" title="10.4常见的时间复杂度"></a>10.4常见的时间复杂度</h3><ol>
<li><p>常数阶O(1)</p>
<p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)</p>
</li>
<li><p>对数阶O(log2n)</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403190429588.png" alt="image-20230403190429588"></p>
<p>说明：在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2n也就是说当循环 log2n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(log2n)  。 O(log2n) 的这个2 时间上是根据代码变化的，i = i * 3 ，则是 O(log3n) .</p>
</li>
<li><p>线性阶O(n)</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403190527125.png" alt="image-20230403190527125"></p>
<p>说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</p>
</li>
<li><p>线性对数阶O(nlog2n)</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403190547667.png" alt="image-20230403190547667"></p>
<p>说明：线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)</p>
</li>
<li><p>平方阶O(n^2)</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403190628389.png" alt="image-20230403190628389"></p>
<p>说明：平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)，这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n<em>n)，即  O(n²) 如果将其中一层循环的n改成m，那它的时间复杂度就变成了 O(m</em>n)</p>
</li>
<li><p>立方阶O(n^3)</p>
</li>
<li><p>k次方阶O(n^k)</p>
</li>
<li><p>指数阶O(2^n)</p>
</li>
</ol>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403185931912.png" alt="image-20230403185931912"></p>
<p>说明：<br>    常见的算法时间复杂度由小到大依次为：Ο(1)＜Ο(log2n)＜Ο(n)＜Ο(nlog2n)＜Ο(n2)＜Ο(n3)＜ Ο(nk) ＜Ο(2n) ，随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低<br>    从图中可见，我们应该尽可能避免使用指数阶的算法</p>
<h3 id="10-5平均时间复杂度和最坏时间复杂度"><a href="#10-5平均时间复杂度和最坏时间复杂度" class="headerlink" title="10.5平均时间复杂度和最坏时间复杂度"></a>10.5平均时间复杂度和最坏时间复杂度</h3><ol>
<li><p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</p>
</li>
<li><p>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</p>
</li>
<li><p>平均时间复杂度和最坏时间复杂度是否一致，和算法有关(如图:)。</p>
<p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230403194803565.png" alt="image-20230403194803565"></p>
</li>
</ol>
<h2 id="11-算法的空间复杂度"><a href="#11-算法的空间复杂度" class="headerlink" title="11.算法的空间复杂度"></a>11.算法的空间复杂度</h2><h3 id="11-1基本介绍"><a href="#11-1基本介绍" class="headerlink" title="11.1基本介绍"></a>11.1基本介绍</h3><ol>
<li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。</li>
<li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模n有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li>
<li>在做算法分析时，主要讨论的是时间复杂度。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis, memcache)和算法(基数排序)本质就是用空间换时间.</li>
</ol>
<h2 id="12-查找算法"><a href="#12-查找算法" class="headerlink" title="12.查找算法"></a>12.查找算法</h2><h3 id="12-1线性查找"><a href="#12-1线性查找" class="headerlink" title="12.1线性查找"></a>12.1线性查找</h3><p>【顺序查找】 如果找到了，就提示找到，并给出下标值</p>
<h3 id="12-2二分查找"><a href="#12-2二分查找" class="headerlink" title="12.2二分查找"></a>12.2二分查找</h3><ol>
<li>首先确定该数组的中间的下标<br>mid = (left + right) / 2</li>
<li>然后让需要查找的数 findVal 和 arr[mid] 比较</li>
<li>1 findVal &gt; arr[mid] ,  说明你要查找的数在mid 的右边, 因此需要递归的向右查找</li>
<li>2 findVal &lt; arr[mid], 说明你要查找的数在mid 的左边, 因此需要递归的向左查找</li>
<li>3  findVal == arr[mid] 说明找到，就返回</li>
</ol>
<p>//什么时候我们需要结束递归.</p>
<ol>
<li>找到就结束递归 </li>
<li>递归完整个数组，仍然没有找到findVal ，也需要结束递归  当 left &gt; right 就需要退出</li>
</ol>
<h3 id="12-3插值查找"><a href="#12-3插值查找" class="headerlink" title="12.3插值查找"></a>12.3插值查找</h3><ol>
<li>插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找。</li>
<li>将折半查找中的求mid 索引的公式 , low 表示左边索引left, high表示右边索引right.key 就是前面我们讲的  findVal</li>
<li>int mid = left + (right – left) * (findVal – arr[left]) / (arr[right] – arr[left])</li>
</ol>
<h3 id="12-4斐波那契-黄金分割法-查找"><a href="#12-4斐波那契-黄金分割法-查找" class="headerlink" title="12.4斐波那契(黄金分割法)查找"></a>12.4斐波那契(黄金分割法)查找</h3><h4 id="12-4-1原理"><a href="#12-4-1原理" class="headerlink" title="12.4.1原理"></a>12.4.1原理</h4><p>斐波那契查找原理与前两种相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割点附近，即mid=low+F(k-1)-1</p>
<p>​    F(k-1)-1：</p>
<ol>
<li>由斐波那契数列 F[k]=F[k-1]+F[k-2] 的性质，可以得到 （F[k]-1）=（F[k-1]-1）+（F[k-2]-1）+1 。该式说明：只要顺序表的长度为F[k]-1，则可以将该表分成长度为F[k-1]-1和F[k-2]-1的两段，即如上图所示。从而中间位置为mid=low+F(k-1)-1          </li>
<li>类似的，每一子段也可以用相同的方式分割</li>
<li>但顺序表长度n不一定刚好等于F[k]-1，所以需要将原来的顺序表长度n增加至F[k]-1。这里的k值只要能使得F[k]-1恰好大于或等于n即可，由以下代码得到,顺序表长度增加后，新增的位置（从n+1到F[k]-1位置），都赋为n位置的值即可。</li>
</ol>
<h2 id="13-哈希表"><a href="#13-哈希表" class="headerlink" title="13.哈希表"></a>13.哈希表</h2><h3 id="13-1基本介绍"><a href="#13-1基本介绍" class="headerlink" title="13.1基本介绍"></a>13.1基本介绍</h3><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p>
<h2 id="14-二叉树"><a href="#14-二叉树" class="headerlink" title="14.二叉树"></a>14.二叉树</h2><h3 id="14-1分析"><a href="#14-1分析" class="headerlink" title="14.1分析"></a>14.1分析</h3><ol>
<li><p>数组存储方式的分析</p>
<p>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检索速度。</p>
<p>缺点：如果要检索具体某个值，或者插入值(按一定顺序)会整体移动，效率较低 </p>
</li>
<li><p>链式存储方式的分析</p>
<p>优点：在一定程度上对数组存储方式有优化(比如：插入一个数值节点，只需要将插入节点，链接到链表中即可， 删除效率也很好)。</p>
<p>缺点：在进行检索时，效率仍然较低，比如(检索某个值，需要从头节点开始遍历) </p>
</li>
<li><p>树存储方式的分析</p>
<p>能提高数据存储，读取的效率,  比如利用 二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。</p>
</li>
</ol>
<h3 id="14-2示意图"><a href="#14-2示意图" class="headerlink" title="14.2示意图"></a>14.2示意图</h3><p><img lazyload src="/images/loading.svg" data-src="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/image-20230404105422385.png" alt="image-20230404105422385"></p>
<p>常用术语</p>
<ol>
<li>节点</li>
<li>根节点</li>
<li>父节点</li>
<li>子节点</li>
<li>叶子节点 (没有子节点的节点)</li>
<li>节点的权(节点值)</li>
<li>路径(从root节点找到该节点的路线)</li>
<li>层</li>
<li>子树</li>
<li>树的高度(最大层数)</li>
<li>森林 :多颗子树构成森林</li>
</ol>
<h3 id="14-3概念"><a href="#14-3概念" class="headerlink" title="14.3概念"></a>14.3概念</h3><ol>
<li>树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。</li>
<li>二叉树的子节点分为左节点和右节点。</li>
<li>如果该二叉树的所有叶子节点都在最后一层，并且结点总数= 2^n -1 , n 为层数，则我们称为满二叉树。</li>
<li>如果该二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称为完全二叉树。</li>
</ol>
<h2 id="15-图"><a href="#15-图" class="headerlink" title="15.图"></a>15.图</h2><h2 id="16-动态规划"><a href="#16-动态规划" class="headerlink" title="16.动态规划"></a>16.动态规划</h2><h3 id="16-1介绍"><a href="#16-1介绍" class="headerlink" title="16.1介绍"></a>16.1介绍</h3><ol>
<li>动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法</li>
<li>动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。</li>
<li>与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )</li>
<li>动态规划可以通过填表的方式来逐步推进，得到最优解.</li>
</ol>

            </div>

            
                <div class="post-copyright-info">
                    <div class="article-copyright-info-container">
    <ul>
        <li>Post title：</li>
        <li>Post author：The Redefine Team</li>
        <li>Create time：2023-03-20 15:21:58</li>
        <li>
            Post link：https://redefine.ohevan.com/2023/03/20/数据结构与算法/
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

                </div>
            

            

            

            
                <div class="article-nav">
                    
                        <div class="article-prev">
                            <a class="prev"
                            rel="prev"
                            href="/2023/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index/"
                            >
                                <span class="left arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-left"></i>
                                </span>
                                <span class="title flex-center">
                                    <span class="post-nav-title-item"></span>
                                    <span class="post-nav-item">Prev posts</span>
                                </span>
                            </a>
                        </div>
                    
                    
                        <div class="article-next">
                            <a class="next"
                            rel="next"
                            href="/2023/03/20/Java%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/index/"
                            >
                                <span class="title flex-center">
                                    <span class="post-nav-title-item"></span>
                                    <span class="post-nav-item">Next posts</span>
                                </span>
                                <span class="right arrow-icon flex-center">
                                    <i class="fa-solid fa-chevron-right"></i>
                                </span>
                            </a>
                        </div>
                    
                </div>
            


            
        </div>

        
            <div class="toc-content-container">
                <div class="post-toc-wrap">
    <div class="post-toc">
        <div class="toc-title">On this page</div>
        <div class="page-title"></div>
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-text">数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E5%86%85%E5%AE%B9%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.数据结构和算法内容介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1%E5%85%88%E7%9C%8B%E5%87%A0%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">1.1.1先看几个经典的算法面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-text">字符串匹配问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%89%E8%AF%BA%E5%A1%94"><span class="nav-text">汉诺塔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98"><span class="nav-text">八皇后问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A9%AC%E8%B8%8F%E6%A3%8B%E7%9B%98"><span class="nav-text">马踏棋盘</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95"><span class="nav-text">2.数据结构和算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">2.1数据结构和算法的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%AE%9E%E9%99%85%E7%BC%96%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">2.2实际编程中遇到的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">2.3数据结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E7%A8%80%E7%96%8Fsparsearray%E6%95%B0%E7%BB%84"><span class="nav-text">3.稀疏sparsearray数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-text">3.1基本介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">3.2稀疏数组和二维数组的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%98%9F%E5%88%97"><span class="nav-text">4.队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E4%BB%8B%E7%BB%8D"><span class="nav-text">4.1介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E9%93%BE%E8%A1%A8"><span class="nav-text">5.链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-text">5.1存储方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-text">5.2逻辑结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8"><span class="nav-text">5.3双向链表应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E5%8D%95%E5%90%91%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">5.4单向环形链表应用场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E6%A0%88"><span class="nav-text">6.栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E4%BB%8B%E7%BB%8D"><span class="nav-text">6.1介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">6.2应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3%E5%AE%9E%E7%8E%B0%E6%A0%88%E7%9A%84%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-text">6.3实现栈的思路分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4%E4%BD%BF%E7%94%A8%E6%A0%88%E5%AE%8C%E6%88%90%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97-%E6%80%9D%E8%B7%AF"><span class="nav-text">6.4使用栈完成表达式的计算 思路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E5%89%8D%E7%BC%80%E3%80%81%E4%B8%AD%E7%BC%80%E3%80%81%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">7.前缀、中缀、后缀表达式(逆波兰表达式)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">7.1前缀表达式(波兰表达式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">7.2中缀表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">7.3后缀表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">7.4中缀表达式转换为后缀表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E9%80%92%E5%BD%92"><span class="nav-text">8.递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1%E9%80%92%E5%BD%92%E9%9C%80%E8%A6%81%E9%81%B5%E5%AE%88%E7%9A%84%E9%87%8D%E8%A6%81%E8%A7%84%E5%88%99"><span class="nav-text">8.1递归需要遵守的重要规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="nav-text">8.2八皇后问题算法思路分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">9.排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">9.1冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">9.2选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">9.3插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">9.4希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-5%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">9.5快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">9.6归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-7%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">9.7基数排序(桶排序)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-7-1%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-text">9.7.1基本思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-7-2%E8%AF%B4%E6%98%8E"><span class="nav-text">9.7.2说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-8%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94"><span class="nav-text">9.8算法对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">10.算法的时间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1%E5%BA%A6%E9%87%8F%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F-%E7%AE%97%E6%B3%95-%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-text">10.1度量一个程序(算法)执行时间的两种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2%E6%97%B6%E9%97%B4%E9%A2%91%E5%BA%A6"><span class="nav-text">10.2时间频度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">10.3时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">10.4常见的时间复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5%E5%B9%B3%E5%9D%87%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E6%9C%80%E5%9D%8F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">10.5平均时间复杂度和最坏时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E7%AE%97%E6%B3%95%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">11.算法的空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-text">11.1基本介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-text">12.查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="nav-text">12.1线性查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-text">12.2二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-text">12.3插值查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%E6%B3%95-%E6%9F%A5%E6%89%BE"><span class="nav-text">12.4斐波那契(黄金分割法)查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#12-4-1%E5%8E%9F%E7%90%86"><span class="nav-text">12.4.1原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-text">13.哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-text">13.1基本介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">14.二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1%E5%88%86%E6%9E%90"><span class="nav-text">14.1分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="nav-text">14.2示意图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-3%E6%A6%82%E5%BF%B5"><span class="nav-text">14.3概念</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E5%9B%BE"><span class="nav-text">15.图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-text">16.动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1%E4%BB%8B%E7%BB%8D"><span class="nav-text">16.1介绍</span></a></li></ol></li></ol></li></ol>

    </div>
</div>
            </div>
        
    </div>
</div>


                

            </div>



        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info">
            &copy;
            
              <span>2022</span>
              -
            
            2023&nbsp;&nbsp;<i class="fa-regular fa-computer-classic"></i>&nbsp;&nbsp;<a href="/">The Redefine Team</a>
        </div>
        
            <script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv" class="busuanzi_container_site_uv">
                        VISITOR COUNT&nbsp;<span id="busuanzi_value_site_uv" class="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="busuanzi_container_site_pv">
                        TOTAL PAGE VIEWS&nbsp;<span id="busuanzi_value_site_pv" class="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            <span class="powered-by-container">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" href="https://hexo.io">Hexo</a></span>
                <br> 
            <span class="theme-version-container">THEME&nbsp;<a class="theme-version" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v1.1.4</a>
        </div>
        
        
        
            <div id="start_time_div" style="display:none">
                2022/8/17 11:45:14
            </div>
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
        
            <script async data-pjax>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="right-bottom-tools page-aside-toggle">
                <i class="fa-regular fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="unfolded-tools-list">
        <li class="right-bottom-tools tool-font-adjust-plus flex-center">
            <i class="fa-regular fa-magnifying-glass-plus"></i>
        </li>

        <li class="right-bottom-tools tool-font-adjust-minus flex-center">
            <i class="fa-regular fa-magnifying-glass-minus"></i>
        </li>

        <li class="right-bottom-tools tool-expand-width flex-center">
            <i class="fa-regular fa-expand"></i>
        </li>

        <li class="right-bottom-tools tool-dark-light-toggle flex-center">
            <i class="fa-regular fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="right-bottom-tools tool-scroll-to-top flex-center">
                <i class="fa-regular fa-arrow-up"></i>
            </li>
        

        <li class="right-bottom-tools tool-scroll-to-bottom flex-center">
            <i class="fa-regular fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="folded-tools-list">
        <li class="right-bottom-tools tool-toggle-show flex-center">
            <i class="fa-regular fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    <div class="image-viewer-container">
    <img src="">
</div>


    


</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/layouts/menu-shrink.js"></script>

<script src="/js/tools/go-top-bottom.js"></script>

<script src="/js/tools/dark-light-toggle.js"></script>





    
<script src="/js/tools/code-block.js"></script>




    
<script src="/js/layouts/lazyload.js"></script>




    
<script src="/js/tools/runtime.js"></script>

    
<script src="/js/layouts/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">





<div class="post-scripts pjax">
    
        
<script src="/js/tools/toc-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/layouts/toc.js"></script>

<script src="/js/plugins/tabs.js"></script>

    
    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            REDEFINE.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            REDEFINE.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            REDEFINE.refresh();
        });
    });
</script>




</body>
</html>
